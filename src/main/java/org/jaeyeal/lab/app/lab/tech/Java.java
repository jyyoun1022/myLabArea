package org.jaeyeal.lab.app.lab.tech;

public class Java {
    // Phyton vs Java vs Kotlin
    /**
     * Python
     * - 인터프리터 언어로 한 줄 씩 컴파일링 된다.
     * - 데이터 타입이 동적으로 입력된다.
     * - 문법이 직관적이고 매우 간단하다.
     * Java
     * - 컴파일링 언어로 한번에 컴파일링 된다.
     * - 정적인 데이터 타입 명시가 필요
     * - JVM으로 실행되어 OS에 관계없이 동작한다.(운영체제 독립성0
     *  = 한번 작성된 Java 프로그램은 어떤 운영체제에서든 JVM이 설치되어있다면 실행될 수 있다
     * Kotlin
     * - 컴파일 타임에 null값에 대한 잘못된 접근을 감지 -> null 안전성
     * - val,var 타입을 통한 타입 선언 불필요
     * - data Class를 통해 java에서 사용되는 보일러플레이트 코드를 줄일 수 있다.
     */

    // Java의 장,단점
    /**
     * 장점
     * - 운영체제에 독립적
     *      => JVM에서 동작하기 떄문에 플랫폼에 종속적이지 않다.
     * - 객체지향언어
     *      => 캡슐화,상속,추상화,다형성 등을 지원하여 객체 지향 프로그래밍이 가능
     * - 동적 로딩을 지원
     *      => 애플리케이션이 실행될 때 모든 객체가 생성되지 않고, 각 객체가 필요한 시점에 클래스를 동적 로딩해서 생성
     *         또한 유지보수 시 해당 클래스만 수정하면 되기 때문에 전체 애플리케이션을 다시 컴파일할 필요가 없다.
     *
     * 단점
     * - 한번의 컴파일링으로 실행 가능한 기계어가 만들어지지 않고 JVM에 의해 기계어로 번역되고 실행되는 과정을 거치기 때문에 느리다.
     */

    // OOP(객체지향 프로그래밍) 특징
    /**
     * 객체지향이란,
     * - 프로그램 구현에 필요한 객체를 파악하고 객체들 간의 상호작용을 통해 프로그램을 만드는 것
     *
     * - 캡슐화
     *      => 정보은닉 : 필요 없는 정보는 외부에서 접근하지 못하도록 제한
     *      => 높은 응집도, 낮은 결합도로 유연함과 유지보수성 증가
     * - 추상화
     *      => 사물들의 공통적인 특징을 파악해서 하나의 개념으로 다루는 것
     *      => 목적과 관련이 없는 부분을 제거하여 필요한 부분만을 표현하기 위함
     * - 상속
     *      => 기존 상위클래스에 근거하여 새롭게 클래스와 행위를 정의할 수 있는 개념
     * - 다형성
     *      => 형태는 같지만 다른기능을 하는 것을 의미
     *      => 오버라이딩, 오버로딩
     */

    // SOLID 원칙
    /**
     * S : 단일 책임 원칙(Single Responsible Principle)
     *      => 객체는 단 하나의 책임만을 가져야한다.
     *      => 어떤 변화에 의해 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다.
     * O : 개방 폐쇄 원칙(Open Closed Principle)
     *      => 기존 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계되어야 한다.
     * L : 리스코프 치환 원칙
     *      => 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다.
     * I : 인터페이스 분리 원칙
     *      => 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
     *      => 인터페이스가 명확해지고, 대체 가능성이 높아진다.
     * D : 의존관계 역전 원칙 (Dependency Inversion Principle)
     *      => 의존 관계를 맺을 떄 변화하기 쉬운 것 또는 자주 변화하는 것보다는 변화하기 어려운것, 거의 변화가 없는것에 의존하라
     *      => 구현클래스에 의존하지말고, 인터페이스에 의존하라.
     *
     *
     */

    // JVM의 구성 요소
    /**
     * 자바 프로그램을 실행하는 역할
     *  - 컴파일를 통해 바이트 코드로 변환된 파일을 JVM에 로딩하여 실행
     *
     *  Class-Loader : JVM 내(Runtime Data Area)로 Class 파일을 로드하고 링크
     *  Execution Engine : 메모리 (Runtime Data Area) 에 적재된 클래스들을 기계어로 변경해 실행
     *  Garbage Collector : 힙 메모리에서 참조되지 않는 개체들 제거
     *  Runtime Data Area : 자바 프로그램을 실행할 때, 데이터를 저장
     */

    // JVM 의 실행과정
    /**
     * 1. JVM은 OS로부터 메모리(Runtime Data Area)를 할당 받음
     * 2. 컴파일러(javac)가 소스코드(.java)를 읽어 바이트코드(.class)로 변환
     * 3. Class Loader를 통해 Class 파일을 JVM내 메모리(Runtime Data Area)로 로딩
     * 4. 로딩된 Class 파일을 Execution Enginge를 통해서 해석 및 실행
     */
    /**
     *  정리
     *  1. 컴파일
     *      => Java 소스는 .java 파일에 저장된다.
     *      => 소스코드는 java컴파일러(javac)에 의해 바이트 코드로 번역되어 .class 파일에 저장된다.
     *  2. 로드
     *      => 클래스 로더 시스템이 컴파일된 클래스 파일을 메모리에 로드한다.
     *      => 로드된 클래스 파일은 JVM의 메서드 영역(Method Area)에 저장
     *  3. 링크
     *      => 로드된 클래스 파일에 대한 링크 작업이 수행된다.
     *          = Verification(검증) : 클래스 파일이 유효한지
     *          = Preparation(준비) : 정적 변수들을 기본값으로 초기화합니다.
     *          = Resolution(해결) : 심볼릭 메모리 참조를 실제 메모리 참조로 변경
     *  4. 초기화
     *      => 클래스 초기화 단계에서 정적 변수들이 명시된 값으로 초기화 된다.
     *      => 클래스의 초기화 블록이 실행됩니다.
     *  5. 메인 메서드 호출
     *      => public static void main(String[] args) 메서드를 찾아 실행
     *  6. 실행
     *      => 필요 에 따라 다른 메서드들이 호출되고 객체가 생성,
     *      => 실행 중 발생하는 데이터는 JVM의 스택영역(Stack) 이나 힙(Heap)에 저장
     *  7. 종료
     */


}
