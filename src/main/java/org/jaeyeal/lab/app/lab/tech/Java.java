package org.jaeyeal.lab.app.lab.tech;

public class Java {
    // Phyton vs Java vs Kotlin
    /**
     * Python
     * - 인터프리터 언어로 한 줄 씩 컴파일링 된다.
     * - 데이터 타입이 동적으로 입력된다.
     * - 문법이 직관적이고 매우 간단하다.
     * Java
     * - 컴파일링 언어로 한번에 컴파일링 된다.
     * - 정적인 데이터 타입 명시가 필요
     * - JVM으로 실행되어 OS에 관계없이 동작한다.(운영체제 독립성0
     *  = 한번 작성된 Java 프로그램은 어떤 운영체제에서든 JVM이 설치되어있다면 실행될 수 있다
     * Kotlin
     * - 컴파일 타임에 null값에 대한 잘못된 접근을 감지 -> null 안전성
     * - val,var 타입을 통한 타입 선언 불필요
     * - data Class를 통해 java에서 사용되는 보일러플레이트 코드를 줄일 수 있다.
     */

    // Java의 장,단점
    /**
     * 장점
     * - 운영체제에 독립적
     *      => JVM에서 동작하기 떄문에 플랫폼에 종속적이지 않다.
     * - 객체지향언어
     *      => 캡슐화,상속,추상화,다형성 등을 지원하여 객체 지향 프로그래밍이 가능
     * - 동적 로딩을 지원
     *      => 애플리케이션이 실행될 때 모든 객체가 생성되지 않고, 각 객체가 필요한 시점에 클래스를 동적 로딩해서 생성
     *         또한 유지보수 시 해당 클래스만 수정하면 되기 때문에 전체 애플리케이션을 다시 컴파일할 필요가 없다.
     *
     * 단점
     * - 한번의 컴파일링으로 실행 가능한 기계어가 만들어지지 않고 JVM에 의해 기계어로 번역되고 실행되는 과정을 거치기 때문에 느리다.
     */

    // OOP(객체지향 프로그래밍) 특징
    /**
     * 객체지향이란,
     * - 프로그램 구현에 필요한 객체를 파악하고 객체들 간의 상호작용을 통해 프로그램을 만드는 것
     *
     * - 캡슐화
     *      => 정보은닉 : 필요 없는 정보는 외부에서 접근하지 못하도록 제한
     *      => 높은 응집도, 낮은 결합도로 유연함과 유지보수성 증가
     * - 추상화
     *      => 사물들의 공통적인 특징을 파악해서 하나의 개념으로 다루는 것
     *      => 목적과 관련이 없는 부분을 제거하여 필요한 부분만을 표현하기 위함
     * - 상속
     *      => 기존 상위클래스에 근거하여 새롭게 클래스와 행위를 정의할 수 있는 개념
     * - 다형성
     *      => 형태는 같지만 다른기능을 하는 것을 의미
     *      => 오버라이딩, 오버로딩
     */

    // SOLID 원칙
    /**
     * S : 단일 책임 원칙(Single Responsible Principle)
     *      => 객체는 단 하나의 책임만을 가져야한다.
     *      => 어떤 변화에 의해 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다.
     * O : 개방 폐쇄 원칙(Open Closed Principle)
     *      => 기존 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계되어야 한다.
     * L : 리스코프 치환 원칙
     *      => 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다.
     * I : 인터페이스 분리 원칙
     *      => 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
     *      => 인터페이스가 명확해지고, 대체 가능성이 높아진다.
     * D : 의존관계 역전 원칙 (Dependency Inversion Principle)
     *      => 의존 관계를 맺을 떄 변화하기 쉬운 것 또는 자주 변화하는 것보다는 변화하기 어려운것, 거의 변화가 없는것에 의존하라
     *      => 구현클래스에 의존하지말고, 인터페이스에 의존하라.
     *
     *
     */

    // JVM의 구성 요소
    /**
     * 자바 프로그램을 실행하는 역할
     *  - 컴파일를 통해 바이트 코드로 변환된 파일을 JVM에 로딩하여 실행
     *
     *  Class-Loader : JVM 내(Runtime Data Area)로 Class 파일을 로드하고 링크
     *  Execution Engine : 메모리 (Runtime Data Area) 에 적재된 클래스들을 기계어로 변경해 실행
     *  Garbage Collector : 힙 메모리에서 참조되지 않는 개체들 제거
     *  Runtime Data Area : 자바 프로그램을 실행할 때, 데이터를 저장
     */

    // JVM 의 실행과정
    /**
     * 1. JVM은 OS로부터 메모리(Runtime Data Area)를 할당 받음
     * 2. 컴파일러(javac)가 소스코드(.java)를 읽어 바이트코드(.class)로 변환
     * 3. Class Loader를 통해 Class 파일을 JVM내 메모리(Runtime Data Area)로 로딩
     * 4. 로딩된 Class 파일을 Execution Enginge를 통해서 해석 및 실행
     */
    /**
     *  정리
     *  1. 컴파일
     *      => Java 소스는 .java 파일에 저장된다.
     *      => 소스코드는 java컴파일러(javac)에 의해 바이트 코드로 번역되어 .class 파일에 저장된다.
     *  2. 로드
     *      => 클래스 로더 시스템이 컴파일된 클래스 파일을 메모리에 로드한다.
     *      => 로드된 클래스 파일은 JVM의 메서드 영역(Method Area)에 저장
     *  3. 링크
     *      => 로드된 클래스 파일에 대한 링크 작업이 수행된다.
     *          = Verification(검증) : 클래스 파일이 유효한지
     *          = Preparation(준비) : 정적 변수들을 기본값으로 초기화합니다.
     *          = Resolution(해결) : 심볼릭 메모리 참조를 실제 메모리 참조로 변경
     *  4. 초기화
     *      => 클래스 초기화 단계에서 정적 변수들이 명시된 값으로 초기화 된다.
     *      => 클래스의 초기화 블록이 실행됩니다.
     *  5. 메인 메서드 호출
     *      => public static void main(String[] args) 메서드를 찾아 실행
     *  6. 실행
     *      => 필요 에 따라 다른 메서드들이 호출되고 객체가 생성,
     *      => 실행 중 발생하는 데이터는 JVM의 스택영역(Stack) 이나 힙(Heap)에 저장
     *  7. 종료
     */

    // 접근 제한자
    /**
     * public : 접근에 제한이 없음
     * private : 자기 자신 클래스 내에서만 접근 가능
     * default : 동일한 패키지 내에서만 접근 가능
     * protected : 동일한 패키지 내에서만 접근 가능 + 상속을 이용한 접근 가능
     */

    // == vs equals
    /**
     * ==
     *      => 참조 비교로 두 객체가 같은 메모리 공간을 가리키는지 확인
     * equals
     *      => 두 객체의 내부 값이 같은지 내용을 비교한다.
     *      => 기본 타입에 대해서는 적용 x
     */

    // 참조 타입
    /**
     * 기본형을 제외하고는 모두 참조형이다.
     * 참조 타입은 데이터의 크기가 가변적이고, 동적이므로 Heap 영역에서 관리된다.
     * 데이터는 Heap 영역에서 관리되지만, 메모리의 주소값은 Stack영역에 담긴다.
     * new 키워드를 이용해 객체를 생성하여 데이터가 생성된 주소를 참조하는 타입
     * 더이상 참조하는 변수가 없을 때 GC에 의해 삭제된다.
     */

    // call by value vs call by reference
    /**
     * Call by Value(값에 의한 호출)
     * 함수 호출 시 인자로 전달되는 변수의 값을 복사하여 함수의 인자로 전달
     * 따라서, 함수 안에서 인자의 값이 변경되어도, 외부의 변수의 값은 변경되지 않는다.
     *
     * Call by Reference(참조에 의한 호출)
     * 함수 호출 시 인자로 전달되는 변수의 레퍼런스를 전달한다.
     * 따라서, 함수 안에서 인자의 값이 변경되면, 인자로 전달된 변수의 값도 함께 변경된다.
     *
     * 자바는 새롭게 지역 변수를 만들어서 값만 복사하고 할당한다. 따라서 Call by Value
     */

    public static void callMain(String[] args) {
        int[] array = {1, 2, 3};
        System.out.println("Before: " + array[0]);
        modifyArray(array);
        System.out.println("After: " + array[0]);
    }

    public static void modifyArray(int[] arr) {
        arr[0] = 10;
        System.out.println("Inside method: " + arr[0]);
    }
//    Before: 1
//    Inside method: 10
//    After: 10

    // hashCode
    /**
     * 두 객체가 동일한 객체인지 비교할 때 사용하고 heap 영역에 저장된 객체의 메모리 주소를 반환한다.
     */

    //wrapperClass
    /**
     * 프로그램에 따라 기본 타입의 데이터를 객체를 취급해야하는 경우가 있다.
     * 예를들어, 메서드의 인수로 객체 타입만이 요구된다면, 기본 타입의 데이터를 그대로 사용할 수는 없다.
     * 이 때 기본 타입의 데이터를 먼저 객체로 변환 후 작업을 수행해야 한다.
     * 래퍼 클래스는 산술 연산을 위해 정의된 클래스가 아니므로, 인스턴스에 저장된 값을 변경할 수 없다.
     *
     */

    // boxing,unboxing
    /**
     * 래퍼클래스는 산술 연산을 위해 정의된 클래스가 아니므로, 인스턴스에 저장된 값을 변경할 수 없다.
     * 단지, 값을 참조하기 위해 새로운 인스턴스를 생성하고, 생성된 인스턴스의 값만을 참조할 수 있다.
     * 기본 타입을 래퍼클래스인스턴스로 변환하는 과정을 박싱,
     * 래퍼클래스의 인스턴스에 저장된 값을 다시 기본타입으로 꺼내는 과정을 언박싱
     */

    // main이 static인 이유
    /**
     * static 멤버는 프로그램 시작 시(클래스 로딩) 메모리에 로드되어 인스턴스를 생성하지 않아도 호출이 가능하기 때문이다.
     */

    // 추상클래스와 인터페이스 차이
    /**
     * 추상 메서드
     *      => abstract 키워드와 함께 원형만 선언되고 코드는 작성하지 않은 메서드
     * 추상 클래스
     *      => 개념 : abstract 키워드로 선언된 클래스
     *          => 추상 메서드가 최소 한개 이상을 가진 abstract 클래스
     *          => 추상 멧더ㅡ 이외의 다른 것들도 추가 가능
     *      => 목적 : 관련성이 높은 클래스 간의 코드를 공유하고 싶은ㅁ 목적
     * 인터페이스
     *      => default * static 을 제외하고는 추상 메서드와 상수만을 포함하여,
     *      => 상수 필드는 public static final 이 생략되어있다.
     *      => 다중상속이 가능하다.
     *
     * 목적 : 관련성이 없는 클래스들의 논리적으로 같은 기능을 자신에 맞게 구현을 강제하는 목적
     *
     */

    // String, StringBuilder, StringBuffer
    /**
     * String
     *      => 새로운 값을 할당할 때마다 새로운 클래스에 대한 객체가 생성
     *      String에 저장되는 문자열은 private final char[]형태이므로 변경할 수 없다.
     *          =>String + String + String..
     *          가비지 컬렉터가 호출되기 전까지 생성된 String 객체들은 Heap에 머물기 때문에 메모리 관리에서 치명적이다.
     * StringBuilder
     *      => 메모리에 append하는 방식으로 클래스에 대한 객체를 생성하지 않는다.
     *      => 비동기처리
     * StringBuffer
     *      => 메모리에 append 하는 방식으로 클래스에 대한 객체를 생성하지 않는다.
     *      => 동기처리
     */












}
